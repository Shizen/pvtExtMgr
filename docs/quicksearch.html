<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" pvtExtMgr Modules pvtExtMgr Modules × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" pvtExtMgr Modules pvtExtMgr Test link pvtExtMgr (Private Extension Manager)The purpose of this extension is to allow you to setup and maintain extensions for your vscode installation which are \"automatically\" kept up to date with a [private] git server. To this end, this module follows the same pattern as npm for specifying and tracking versions of npm modules*. This module allows the user to specify in this module's settings a dependencies-like list of #semver npm references to a git server and semver version specification for the desired version of the extension they would like to have installed. The primary goal is to support user developed and private extensions in vscode. Note that the actual semver math is done by semver-extra, which, among other things, allows you to specify :prerelease as a semver specification which will match against prelrease versions of the package (to get the latest possible version--:prerelease is an alias for max() in semver-extra terminology). See semver-extra for more details. Features Allows the user to trigger (manually for the moment), the checking for updates to extensions stored in git repos according the user settings for this extension. Can be made to keep a log of updates performed. Known Issues Sanitation of \"private\" ip addresses and the like has caused certain dev related facilities to fall down. RequirementsThis extension requires that the user already have git and npm installed and included in their path. Extension SettingspvtExtMgr.extensions : This is the most important setting for this extension. This setting lists which extensions you want pvtExtMgr to update for you and via which rule. This setting uses a subset of the npm dependency format--it will only accept #semver rules. Any other format will be ignored. \"pvtExtMgr.extensions\": { \"jsdoc-view\": \"git+ssh://git@127.0.0.1:/srv/git/jsdoc-view.git#semver:prerelease\", \"shinmark\": \"git+ssh://git@127.0.0.1:/srv/git/shinmark.git#semver:latest\", \"pvtExtMgr\": \"git+ssh://git@127.0.0.1:/srv/git/vscExt-pvtExtMgr.git#semver:~0.0.2\" }This setting does extend the #semver format to add prerelease and latest as options. latest will follow the standard dependencies definition for versioning. prerelease will take the latest version, including prereleases. These maths are provided courtesy of the semver-extra module. pvtExtMgr.clean : (defaults to true) If set to true, any module updated by this extension will also have a git clean -f run to remove any deleted files. pvtExtMgr.keepLog : (defaults to false) If set to true, will cause this module to keep a log of its installation efforts in its extension directory. Log management is a thing, and this extension doesn't make any attempt to manage them. Intended primarily for troubleshooting. Known Issues I currently \"update\" extensions via fetch + checkout. (which will fetch all branches of the given repos). Does not verify that the user has permissions to update the extension(s) in question. To be clear, here I mean perms to modify the local file system. This falls under error handling &amp; robustness This module does not debounce for multiple instances. By which I mean that it does not deal gracefully with the situation where a user has multiple instances of vscode open and executes an update from each of them at \"the same time\". (Which is why this extension is setup currently to be triggered manually). On a related note, this extension makes no attempt to notify other vscode instances that extensions have been altered and need to be reloaded. VSCode itself appears hit or miss on noticing during informal testing, but this might well be related to whether a given extension was activated. This module has not been tested on the Mac or Linux (I don't have either setup atm). Pathing may be dorked on such platforms. I have done no testing for any of the myriad of git security/setups that might be in place. I use ssh with installed keys. Not tested with older versions of npm (only tested with npm 6). I could pretty print my dates more Could put in more detailed progress bar status updates Futures This extension currently only runs when triggered manually. It could be extended to run when vscode starts up. It would be easy to add support for the \"commitish\" format as well. This extension now runs exclusively in async mode. For performance reasons, update requests could be \"grouped\" to take advantage of processor speed. Currently, updates are performed serially (in tandem). Settings to allow one to specify a specific git or npm client to use. Support for custom credentials by extension Support to allow the user to trigger an update/check for a specific repos or with special conditions (no npm install, no git clean, etc.) Release Notes 0.0.2 : Initial Release × Search results Close "},"module-pvtExtMgr.html":{"id":"module-pvtExtMgr.html","title":"Module: pvtExtMgr","body":" pvtExtMgr Modules pvtExtMgr Module: pvtExtMgr Private Extension Manager This vscode extension facilitates the use/maintenance of private extensions in vscode. This module leverages npm's semver module (and semver-extra) to allow for tracking and auto-updating of vscode extensions from private git repos using semver maths. For purposes of this module, tracking is done not via the actual contents of a module's package.json, but rather by the tags on its git repository (e.g. by version tag ala npm version). algorithm The name of the extension is assumed to match the folder the extension is located in within vscode's extensions directory. Updating an extension involves... pulling the extension from its git repos (by tag; technically this is currently fetched then checked out) if (clean) is set, git clean -f npm install × Search results Close "},"tutorial-DESIGN.html":{"id":"tutorial-DESIGN.html","title":"Tutorial: DESIGN","body":" pvtExtMgr Modules pvtExtMgr DESIGN #{ Pre-Release checklist branch release and dev, clean/purge releaseThe concept is to have a dev branch which we store on AWS, and a stripped, presentable version on github. This is kind of a pita, though, if one imagines actually stripping comments by hand every time. So, really I'd want to strip designated internal comments as mentioned... Because doing a separate clean is rediculous. Ok. But I don't have this facility at the moment. So leave the various comments in? //. mumble. Trouble is I can't easily ctrl-/ such things. I could strip all non // comments, but that seems \"bad\". Basically I want a comment vs. an ignore. I can implement this by basically saying, ctrl-/ will insert /// instead of // and /// is ignore. I could instead try to alter my patterns and reserve // for ignore and /* */ for comments, but I think this is probably unwise. Ideally, tools like git would also ignore ignore-lines, so a file with differing /// would still be considered the same, so long as everything else was the same--so I could have my /// and someone else could have their own /// comments. The merge/move/floating aspects would be rough. bother. } #{ ToDo Convert my execSync calls to async calls and leverage gitExecSync. Each individual extension test can be \"forked\" in its own async process, but within a process, it's easier to use gitExecFauxSync, or whatever I'm calling it. That is probably in grunt build tasks, which tells me that I probably want to move it out into a more generic lib. Even grunt-utils turns out to be too narrow in naming. I should probably fix that. debounce reload extensions (in all open vscode instances) -- A little controversial. I'd have to open a second named pipe to communicate between my various extensions in each vscode instance, which feels a bit like using napalm to swat a fly, but... It would work. Also would require that this extension always be active in every vscode instance. Validation &amp; Robustness validate that git and npm are installed/in path verify that the extension in question is an npm module under git. security and access perms Features allow commitish format (e.g. #master) could set up a communication channel between the various workers and myself, but that seems like overkill. It would allow me to \"easily\" relay update information from the various threads to the main. Also using a named pipe would allow debouncing between vscode instances. } #{ Links semver semver-extra } Private Extension ManagerThe idea behind this vscode extension is to allow for the management and automatic updating of vscode extensions from one or more private github servers. To this end, I would have a setting in the extension which would look similar to a package's dependency list (in format), utilizing the github format. Ideally I'd use the exact same semver math and code as npmm, utilizing the same tagging semantics for githubs in pulling the extensions. Design Decisions and DebatesExtension formatI could walk all the extensions and look for ones which are not public, but that's invasive and fragile. Instead, I'm explicitly only managing extensions which have entries in my settings. For these, I am taking their path/info from what is entered in my settings. I could look for the source information from the repository field in the appropriate package.json, but I'm not going to. Not even as a fallback. I think. PrereleasesSo, I didn't really think about this before, but semver does not deal with prerelease versions. This shouldn't surprise me because of what semver is designed to do and the definition of what it means to be a prerelease version. Of course, I actually want to use prerelease versions of my own extensions. Or, at least, sometimes I do. I think. I'm not really sure that's true though. I suspect that if I was honest, I would recognize that this is a case where I should just do release versions of my extensions that I wanted released. But... that's not convenient for me at this moment. So, let's say, for sake of argument that I want to support auto grabbing and installing prerelease versions, which the more I think about it, the less I think that's wise, but whatever. Maybe I will only allow it from a specific command extension, but then I'd not want to do it for all extensions I suspect. Which is exactly where I was going--how do I want to architect it then? Apriori we have recognized that most of the time we don't want to use this behavior. I think it is also clear that we don't to exercise this behavior in a blanket methodology for all the extensions we're managing. So it needs to be a setting of some sort that we specify for a specific module/extension on a case by case behavior. The simplest method I can think of is to use an alternate of #semver:... like #semver-prerelease:. That means we'd have to set it in the settings, and not be all.. just do it this one time. I think if I was going to do it as a one-time thing I'd want to execute a command that would let me pick an extension that exists (or maybe enter/pick one) and then enter a custom semver line. Not necessary for the moment, and requires like.. UI, which I haven't looked at doing in vscode yet. I digress. URLFor compliance, consistancy type considerations, I'm using Node's url parser to parse setting entries. All good so far, but may introduce issues later. Dev log Ran into an interesting problem with deasync and node-gyp. Apparently for some reason, my extension is not building its native extension support code. This appears to be a \"bug\" in vscode, in that it's looking for .node files in the wrong directory from where deasync as put them and deasync is the first?!? gypped/native module I've used?!? Which is possible.So some research shows me that vscode (which recall is built on electron), uses the node-bindings module to search for \"native\" node-gypped .node files. This module checks in a bunch of places, none of which are where deasync puts its gypped files. More research is required. × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
